#
# Top level xscale_sw Makefile, will call OSAL & BSP Makefile
# 
# @par
# IXP400 SW Release Crypto version 2.0
# 
# -- Intel Copyright Notice --
# 
# @par
# Copyright 2002-2005 Intel Corporation All Rights Reserved.
# 
# @par
# The source code contained or described herein and all documents
# related to the source code ("Material") are owned by Intel Corporation
# or its suppliers or licensors.  Title to the Material remains with
# Intel Corporation or its suppliers and licensors.
# 
# @par
# The Material is protected by worldwide copyright and trade secret laws
# and treaty provisions. No part of the Material may be used, copied,
# reproduced, modified, published, uploaded, posted, transmitted,
# distributed, or disclosed in any way except in accordance with the
# applicable license agreement .
# 
# @par
# No license under any patent, copyright, trade secret or other
# intellectual property right is granted to or conferred upon you by
# disclosure or delivery of the Materials, either expressly, by
# implication, inducement, estoppel, except in accordance with the
# applicable license agreement.
# 
# @par
# Unless otherwise agreed by Intel in writing, you may not remove or
# alter this notice or any other notice embedded in Materials by Intel
# or Intel's suppliers or licensors in any way.
# 
# @par
# For further details, please see the file README.TXT distributed with
# this software.
# 
# @par
# -- End Intel Copyright Notice --
#
# WARNING: This version of the makefile includes support for
# export-controlled cryptography features. It must not be released to
# "controlled countries", as defined by US export laws.
#

################################################################
# Determine the build host OS

# In a Tornado environment, WIND_HOST_TYPE should be set
ifeq ($(WIND_HOST_TYPE), x86-win32)
  IX_HOST_OS := windows
else
  ifeq ($(WIND_HOST_TYPE), sun4-solaris2)
    IX_HOST_OS := solaris
  else
    # Otherwise, try OSTYPE
    IX_HOST_OS := $(OSTYPE)
  endif
endif

# If we don't have a valid OS name, try to use the Unix uname command
# to find it.
ifeq (,$(filter $(IX_HOST_OS), linux solaris windows))
  IX_HOST_OS := $(shell uname)
  IX_HOST_OS := $(subst Linux,linux,$(IX_HOST_OS))
  IX_HOST_OS := $(subst SunOS,solaris,$(IX_HOST_OS))
# We do not check for 'cygwin' here, as a windows box will often have
# a cygwin "uname" on its PATH even when not running in a true cygwin
# environment. We must rely on the OSTYPE environment variable to tell
# us if we're in a true cygwin environment.
endif
# If we still don't know, assume it's Windows
ifeq (,$(filter $(IX_HOST_OS), linux solaris windows))
  IX_HOST_OS := windows
endif

################################################################
# Target OS selection

ifneq (,$(filter $(IX_TARGET), linuxbe linuxle))
IX_TARGET_OS := linux
else
IX_TARGET_OS := vxworks
endif

################################################################
# Component lists
#
# Only check in the makefile with your component listed here if
# you know it will build.
#
# Components listed in BI_ENDIAN_COMPONENTS must work for all target
# platforms and both ixp42X and ixp46X devices. 
# Components that work only for a subset of platforms
# should be added to the relevant *_COMPONENTS lists.
#
# BI_ENDIAN_COMPONENTS := atmdAcc atmm atmsch qmgr npeMh npeDl ethAcc ethDB ethMii hssAcc usb uartAcc featureCtrl ossl osServices 
# 定义实际需要编译的AccessLibrary模块， 李志杰，2005.07.11
BI_ENDIAN_COMPONENTS := qmgr npeMh npeDl ethAcc ethDB ethMii featureCtrl ossl osServices 

# delete this component from image ,李志杰，2005.07.18
# ifndef IX_CONTROLLED_COUNTRY_BUILD
# BI_ENDIAN_COMPONENTS += cryptoAcc
# endif # !IX_CONTROLLED_COUNTRY_BUILD

#Components only applicable to ixp46x
ixp46X_BI_ENDIAN_COMPONENTS := timeSyncAcc parityENAcc i2c sspAcc
ifndef IX_CONTROLLED_COUNTRY_BUILD
ixp46X_BI_ENDIAN_COMPONENTS +=
endif # !IX_CONTROLLED_COUNTRY_BUILD

# The lists below contain the set of components available for each target platform
vxbe_COMPONENTS := $(BI_ENDIAN_COMPONENTS) perfProfAcc dmaAcc
vxle_COMPONENTS := $(BI_ENDIAN_COMPONENTS) perfProfAcc
vxsim_COMPONENTS := $(BI_ENDIAN_COMPONENTS) dmaAcc
# linuxbe_COMPONENTS := $(BI_ENDIAN_COMPONENTS) perfProfAcc dmaAcc oslinux
# 修改为下面的一句，李志杰，2005.07.11；NPE微码使用静态连接的方式
linuxbe_COMPONENTS := $(BI_ENDIAN_COMPONENTS) dmaAcc 
linuxle_COMPONENTS := $(BI_ENDIAN_COMPONENTS) perfProfAcc oslinux

#The lists below contain the set of components available for each target platform
# specific to the ixp46X device
ixp46X_vxbe_COMPONENTS := $(ixp46X_BI_ENDIAN_COMPONENTS) \
 $(vxbe_COMPONENTS)
ixp46X_vxle_COMPONENTS := $(ixp46X_BI_ENDIAN_COMPONENTS) \
 $(vxle_COMPONENTS)
ixp46X_vxsim_COMPONENTS := $(ixp46X_BI_ENDIAN_COMPONENTS) \
$(vxsim_COMPONENTS)
ixp46X_linuxbe_COMPONENTS := $(ixp46X_BI_ENDIAN_COMPONENTS) \
                                      $(linuxbe_COMPONENTS)
ixp46X_linuxle_COMPONENTS := $(ixp46X_BI_ENDIAN_COMPONENTS) \
                                      $(linuxle_COMPONENTS)

# To facilitate automated builds, do not modify the value of COMPONENTS directly - 
# just change the per-platform component lists above.
ifeq ($(IX_DEVICE),ixp46X)
COMPONENTS:=$($(IX_DEVICE)_$(IX_TARGET)_COMPONENTS)
else
COMPONENTS := $($(IX_TARGET)_COMPONENTS)
endif

################################################################
# Codelet components
# Codeletes listed in BI_ENDIAN_CODELETS_COMPONENTS must work for both
# big and little endian OSs.
# BI_ENDIAN_CODELETS_COMPONENTS := hssAcc ethAcc perfProfAcc atm
# 定义实际需要编译的codelet，李志杰，2005.07.11

# comment cryptoAcc codelet, 李志杰, 2005.07.18
# BI_ENDIAN_CODELETS_COMPONENTS := 
# ifndef IX_CONTROLLED_COUNTRY_BUILD
# BI_ENDIAN_CODELETS_COMPONENTS += cryptoAcc
# endif # !IX_CONTROLLED_COUNTRY_BUILD

#Codelet components only applicable to ixp46x
ixp46X_BI_ENDIAN_CODELETS_COMPONENTS := timeSyncAcc parityENAcc
ifndef IX_CONTROLLED_COUNTRY_BUILD
ixp46X_BI_ENDIAN_CODELETS_COMPONENTS += 
endif # !IX_CONTROLLED_COUNTRY_BUILD

vxbe_CODELETS_COMPONENTS := $(BI_ENDIAN_CODELETS_COMPONENTS) dmaAcc
vxle_CODELETS_COMPONENTS := $(BI_ENDIAN_CODELETS_COMPONENTS)
vxsim_CODELETS_COMPONENTS := $(BI_ENDIAN_CODELETS_COMPONENTS) dmaAcc

# linuxbe_CODELETS_COMPONENTS := $(BI_ENDIAN_CODELETS_COMPONENTS) dmaAcc
# 修改为下面的一句
linuxbe_CODELETS_COMPONENTS := $(BI_ENDIAN_CODELETS_COMPONENTS) 
linuxle_CODELETS_COMPONENTS := $(BI_ENDIAN_CODELETS_COMPONENTS)

#The lists below contain the set of components available for each target platform
# specific to the ixp46X device
ixp46X_vxbe_CODELETS_COMPONENTS := $(ixp46X_BI_ENDIAN_CODELETS_COMPONENTS) \
                                   $(vxbe_CODELETS_COMPONENTS)
ixp46X_vxle_CODELETS_COMPONENTS := $(ixp46X_BI_ENDIAN_CODELETS_COMPONENTS) \
                                   $(vxle_CODELETS_COMPONENTS)
ixp46X_vxsim_CODELETS_COMPONENTS := $(ixp46X_BI_ENDIAN_CODELETS_COMPONENTS) \
                                    $(vxsim_CODELETS_COMPONENTS)
ixp46X_linuxbe_CODELETS_COMPONENTS := $(ixp46X_BI_ENDIAN_CODELETS_COMPONENTS) \
                                      $(linuxbe_CODELETS_COMPONENTS)
ixp46X_linuxle_CODELETS_COMPONENTS := $(ixp46X_BI_ENDIAN_CODELETS_COMPONENTS) \
                                      $(linuxle_CODELETS_COMPONENTS)

ifeq ($(IX_DEVICE),ixp46X)
CODELETS_COMPONENTS:=$($(IX_DEVICE)_$(IX_TARGET)_CODELETS_COMPONENTS)
else
CODELETS_COMPONENTS :=$($(IX_TARGET)_CODELETS_COMPONENTS)
endif


################################################################
# List of all the components we know about
ALL_COMPONENTS := $(COMPONENTS) 
ALL_COMPONENTS += $(CODELETS_COMPONENTS:%=codelets_%)

################################################################
# vxWorks BSP selection
#
ifeq ($(IX_PLATFORM),ixdp46x)
ifeq ($(IX_TARGET),vxle)
BSP := ixdp465_le
else
BSP := ixdp465
endif
else
ifeq ($(IX_TARGET),vxle)
BSP := ixdp425_le
else
BSP := ixdp425
endif
endif

BSP_DIR := $(WIND_BASE)/target/config/$(BSP)

# Windows paths must use '\' as seperator for the MSDOS 'cd' command
ifeq ($(IX_HOST_OS),windows)
 BSP_DIR := $(subst /,\,$(BSP_DIR))
endif


################################################################
# Linux kernel source

LINUX_SRC := $($(IX_TARGET)_KERNEL_DIR)

################################################################
# Input directory - mostly for passing to sub-makes
# For linux, this is defined in the environment, for vxWorks the 
# name of the environment variable is different for historical 
# reasons.
ifeq ($(IX_TARGET_OS),vxworks)
IX_XSCALE_SW := $(CSR_BASE)
endif

################################################################
# Output directories 
#

ifeq ($(IX_DEVICE),ixp46X)
OBJ_DIR := $(IX_DEVICE)/lib/$(IX_TARGET)
else
OBJ_DIR := lib/$(IX_TARGET)
endif

METRICS_DIR := metrics

OUTPUT_DIRS := lib ixp46X ixp46X/lib $(OBJ_DIR) \
	$(foreach c, $(COMPONENTS), $(OBJ_DIR)/$c $(OBJ_DIR)/$c/test)
OUTPUT_DIRS += $(OBJ_DIR)/codelets \
	$(CODELETS_COMPONENTS:%=$(OBJ_DIR)/codelets/%)

# The directory containing the production object files from the NPE
# build system including IxNpeMicrocode.[c|h|o] files
# NPE_OUTPUT_DIR := npeLib
# OUTPUT_DIRS += $(NPE_OUTPUT_DIR)

################################################################
# OSAL selection
ifneq (,$(filter $(IX_DEVICE), ixp46X))
IX_TGT_DEVICE := ixp465
else
IX_TGT_DEVICE := ixp425
endif

OSAL_DIR := $(IX_XSCALE_SW)/../ixp_osal
OSAL_IMAGE := ../ixp_osal/lib/$(IX_TGT_DEVICE)/$(IX_TARGET_OS)/$(IX_TARGET)/libosal.a
OSAL_MODULE := ../ixp_osal/lib/$(IX_TGT_DEVICE)/$(IX_TARGET_OS)/$(IX_TARGET)/ixp_osal.o

.PHONY: osal_build
osal_build :
	echo cd into $(OSAL_DIR)
	cd $(OSAL_DIR) $(CMD_SEP) $(MAKE) libosal IX_TARGET=$(IX_TARGET)

$(OSAL_IMAGE) : osal_build

.PHONY: osal_module
osal_module :
	echo cd into $(OSAL_DIR)
	cd $(OSAL_DIR) $(CMD_SEP) $(MAKE) module IX_TARGET=$(IX_TARGET)

$(OSAL_MODULE) : osal_module

################################################################
# Compiler & linker commands
#

ifeq ($(IX_TARGET_OS),vxworks)

# Suffix for Tornado tool names
ifeq ($(IX_TARGET),vxsim)
VX_TOOL_SUFFIX = simso
else
VX_TOOL_SUFFIX = arm
endif

  CC := cc$(VX_TOOL_SUFFIX)
LD := $(CC)
AR := ar$(VX_TOOL_SUFFIX)

# These are tools used to make a .out file with vxWorks ctor/dtor table.
NM := nm$(VX_TOOL_SUFFIX)
MUNCH := wtxtcl $(WIND_HOST_BASE)/host/src/hutils/munch.tcl -asm $(VX_TOOL_SUFFIX)
COMPILE_TRADITIONAL := $(CC) -c -fdollars-in-identifiers

# This is used for the 'memusage' target
OBJDUMP := objdump$(VX_TOOL_SUFFIX)

else # IX_TARGET_OS == vxworks

# Linux tool names
ifeq ($(IX_TARGET), linuxbe)
# LINUX_CROSS_COMPILE := $(HARDHAT_BASE)/devkit/arm/xscale_be/bin/xscale_be-
LINUX_CROSS_COMPILE := arm-linux-
else
# LINUX_CROSS_COMPILE := $(HARDHAT_BASE)/devkit/arm/xscale_le/bin/xscale_le-
LINUX_CROSS_COMPILE := arm-linux-
endif

LD := $(LINUX_CROSS_COMPILE)ld
CC := $(LINUX_CROSS_COMPILE)gcc
AR := $(LINUX_CROSS_COMPILE)ar

# This is used for the 'memusage' target
OBJDUMP := $(LINUX_CROSS_COMPILE)objdump

endif

################################################################
# Compiler & linker options
#

ifeq ($(IX_TARGET_OS),vxworks)
# vxWorks compiler flags
CFLAGS := -Wall -ansi -pedantic -DRW_MULTI_THREAD -D_REENTRANT \
	-Isrc/include -I$(WIND_BASE)/target/h -I$(BSP_DIR) \
	-I$(BSP_DIR)/../all -fno-common
# vxWorks linker flags
LDFLAGS := -nostdlib -r -Wl,-X
else
# linux compiler flags 

LINUX_MACH_CFLAGS := -D__LINUX_ARM_ARCH__=5 -mcpu=xscale -mtune=xscale

CFLAGS := -D__KERNEL__ -I$(LINUX_SRC)/include -Wall -Wno-trigraphs -fno-common -pipe -mapcs-32 -mshort-load-bytes -msoft-float -DMODULE -Isrc/include -D__linux -DCPU=33 -DXSCALE=33 $(LINUX_MACH_CFLAGS)
ifndef IX_INCLUDE_MICROCODE
CFLAGS += -DIX_NPEDL_READ_MICROCODE_FROM_FILE
endif

# Linux linker flags
LDFLAGS := -r

ifeq ($(IX_TARGET),linuxbe)
CFLAGS += -mbig-endian
LDFLAGS += -EB
else
CFLAGS += -mlittle-endian
LDFLAGS += -EL
endif

endif


ifdef IX_EXTRA_WARNINGS
# Optional "aggressive" warning flags. These will produce a lot of warning
# messages about Linux and vxWorks header files, but there should still be
# no warnings in Intel production code.
CFLAGS += -Wsign-compare -Wformat -Wstrict-prototypes -Wshadow -Wmissing-prototypes \
	-Wmissing-declarations -Wnested-externs -Winline -Waggregate-return \
	-fstrict-aliasing -fno-builtin -fsigned-char
endif

ifndef IX_MPHY
CFLAGS += -DIX_UTOPIAMODE=1
endif

ifdef IX_MPHYSINGLEPORT
CFLAGS += -DIX_MPHYSINGLEPORT=1
endif


ifeq ($(IX_TARGET_OS),linux)
# Default to build without debug symbols for Linux
IX_NOSYM := 1
endif

ifndef IX_NOSYM
CFLAGS += -ggdb3
endif

ifndef IX_NOOPT
CFLAGS += -O2
endif

ifdef IX_ENSURE_OFF
CFLAGS += -DIX_ENSURE_OFF
endif

ifdef IX_PRIVATE_OFF
CFLAGS += -DIX_PRIVATE_OFF
endif

ifndef IX_DEBUG
# Note: If you change the flags added here, be sure to modify the
# (filter-out) statement in the definition of
# ASM_C_RULES_UNITTEST_FLAGS to remove the same flags.
CFLAGS += -DNDEBUG
endif

# Target platform dependent options

ifeq ($(IX_TARGET),vxsim)
  CFLAGS += -DCPU=SIMSPARCSOLARIS
else
  ifeq ($(IX_TARGET_OS),vxworks)
    LDFLAGS += -Wl
    CFLAGS += -mcpu=xscale -mapcs-32 -mno-sched-prolog \
	-DCPU=XSCALE -DCPU_XSCALE -DARMMMU=ARMMMU_XSCALE \
	-DARMCACHE=ARMCACHE_XSCALE
    ifeq ($(IX_TARGET),vxle)
      LDFLAGS += -mlittle-endian 
      CFLAGS += -mlittle-endian -DARMEL -DLITTLE_ENDIAN_MODE
    else
      LDFLAGS += -mbig-endian 
      CFLAGS += -mbig-endian -DARMEB -DBIG_ENDIAN_MODE
    endif
  endif
endif


CFLAGS += -I$(OSAL_DIR)/ \
          -I$(OSAL_DIR)/os/$(IX_TARGET_OS)/include/ \
          -I$(OSAL_DIR)/os/$(IX_TARGET_OS)/include/modules/ \
          -I$(OSAL_DIR)/os/$(IX_TARGET_OS)/include/modules/ioMem/ \
          -I$(OSAL_DIR)/os/$(IX_TARGET_OS)/include/modules/core/ \
          -I$(OSAL_DIR)/os/$(IX_TARGET_OS)/include/modules/bufferMgt/ \
          -I$(OSAL_DIR)/os/$(IX_TARGET_OS)/include/core/  \
          -I$(OSAL_DIR)/os/$(IX_TARGET_OS)/include/platforms/ \
          -I$(OSAL_DIR)/os/$(IX_TARGET_OS)/include/platforms/ixp400/ \
          -I$(OSAL_DIR)/os/$(IX_TARGET_OS)/include/core/ \
          -I$(OSAL_DIR)/include/ \
          -I$(OSAL_DIR)/include/modules/ \
          -I$(OSAL_DIR)/include/modules/bufferMgt/ \
          -I$(OSAL_DIR)/include/modules/ioMem/ \
          -I$(OSAL_DIR)/include/modules/core/ \
          -I$(OSAL_DIR)/include/platforms/ \
          -I$(OSAL_DIR)/include/platforms/ixp400/ \
          -I$(OSAL_DIR)/include/platforms/ixp400/$(IX_TGT_DEVICE)/ \
          -I$(OSAL_DIR)/os/$(IX_TARGET_OS)/include/platforms/ixp400/$(IX_TGT_DEVICE)/
        
CFLAGS += $(IX_CFLAGS) 
LDFLAGS += $(IX_LDFLAGS)

#Set additions to the compiler flag based on device chosen
ifeq ($(IX_DEVICE),ixp46X)
CFLAGS += -D__ixp46X
ifeq ($(IX_TARGET_OS),vxworks)
CFLAGS += -DIX_FLASH_SIZE_32M
endif
else
CFLAGS += -D__ixp42X
endif

################################################################
# Other commands
#

# A sed command to process the output of $(CC) -M. It prepends a
# directory name to the object filename and adds the .d file to the
# rule as a rule target, and then appends the name of this makefile
# and the component makefile corresponding to the particular object as
# a dependency.
#
# Note the use of '=' rather than ':=' so that the value of $* will
# be evaluated later, when we use the command within a template rule.
#
# Note where '$$' is used in the sed commands, 'make' interprets it as
# a single '$'.
FILTER_DEPS = sed -e $(SAFE_QUOTE)s,$(notdir $*)\.o,$(OBJ_DIR)/$*.d $(OBJ_DIR)/$*.o,g$(SAFE_QUOTE) \
			-e $(SAFE_QUOTE)$$s,$$, src/$(dir $*)component.mk Makefile,$(SAFE_QUOTE)

# A command for printing trace messages in the makefile.
MAKEFILE_TRACE := @echo $(ECHO_QUOTE)--- Makefile: $(ECHO_QUOTE) # Use this setting to enable messages
#MAKEFILE_TRACE = @\#  # Use this setting to disable messages

################################################################
# Build platform specific macros
#
# These are : CMD_SEP : the string we use to seperate multiple
# 			commands on a single line.
#             ECHO_QUOTE : to print leading whitespace with the unix
#                       shells' echo command, we need quotes.
#             SAFE_QUOTE : the qoute character needed to enclose a 
#                       'sed' command.
#	      ECHO_BLANKLINE : The command to print an empty line.
#             RM : unconditionally delete file(s)

ifeq ($(IX_HOST_OS),windows)
# Windows settings
CMD_SEP := &&
ECHO_QUOTE := # cmd.exe's echo command doesn't need quotes
ECHO_BACKSLASH := \# comment needed to keep \ away from end of line
SAFE_QUOTE := "# " this comment is here to fix emacs syntax highlighting 
ECHO_BLANKLINE := @cmd.exe /c echo.
RM := vxrm 
# Windows doesn't have a 'touch' command. Warning! Unlike Unix touch,
# this will overwrite the existing file!
TOUCH_EMPTY_FILE := echo. >
else
# Unix settings
CMD_SEP := ;
ECHO_QUOTE := "# " this comment is here to fix emacs syntax highlighting 
ECHO_BACKSLASH := \\
SAFE_QUOTE := '# ' this comment is here to fix emacs syntax highlighting 
ECHO_BLANKLINE := @echo
RM := rm -f
TOUCH_EMPTY_FILE := touch
endif

################################################################
# Component makefiles
#

# Include component code makefiles
ifneq (0,$(words $(COMPONENTS)))
include $(COMPONENTS:%=src/%/component.mk)
endif
# COMPONENT_OBJ lists all of the object files in components
COMPONENT_OBJ := $(foreach c, $(COMPONENTS), $($(c)_OBJ:%=$(OBJ_DIR)/$(c)/%))

# Include codelet makefiles
ifneq (0,$(words $(CODELETS_COMPONENTS)))
include $(CODELETS_COMPONENTS:%=src/codelets/%/component.mk)
endif
# CODELETS_OBJ lists all the codelet objects
CODELETS_OBJ := $(foreach c, $(CODELETS_COMPONENTS), \
	$(codelets_$(c)_OBJ:%=$(OBJ_DIR)/codelets/$c/%))


# ALL_OBJ list all of the object files we know about
ALL_OBJ := $(COMPONENT_OBJ) $(CODELETS_OBJ)

# ALL_EXPORT_OBJ lists all of the object files that export symbols to
# the Linux kernel symbol table (This has no effect for non-linux
# builds).  Note that this list should be a subset of ALL_OBJ.
ALL_EXPORT_OBJ := $(foreach c, $(ALL_COMPONENTS), \
			$($(c)_EXPORT_OBJ:%=$(OBJ_DIR)/$(subst _,/,$(c))/%) \
		   )


################################################################
# Rules
#

# Default target
usage:
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)xscale_sw/Makefile usage$(ECHO_QUOTE) 
	@echo $(ECHO_QUOTE)------------------------$(ECHO_QUOTE) 
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)Targets:$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)--------$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)make vxWorks COMP=(component)$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  builds a vxWorks OS image containing component code and $(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  and component dependencies$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)make vxWorks.st COMP=(component)$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  similar to above, but builds a standalone image.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)make vxWorks-all$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  runs a 'make vxWorks' for each component. Note each image will$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  overwrite the previous one, so this is useful only to check for $(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  build errors.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)make loadable COMP=(component)$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  builds a relocatable .out image of component code, test code$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  and component test dependencies$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)make loadable-all$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  builds all possible loadable objects.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)make lib COMP=(component)$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  builds a library of component code$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)make module COMP=(component)$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  builds a linux kernel module of component code$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)make ixp400.o$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  builds a linux kernel module containing the access drivers$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)make modules$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  builds all of the linux kernel modules$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)make check COMP=(component) VXTARGET=(vxworks target)$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  builds and runs a component unit test, diffs the output$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  against src/(component)/test/expected.out.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)make coverage COMP=(component) VXTARGET=(vxworks target)$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  builds and runs a component unit test, writes code coverage$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  data to $(METRICS_DIR)/. This target will include only $(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  production code for a single component.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)make run-coverage COMP=(component) VXTARGET=(vxworks target)$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  similar to 'make coverage', but can include unit test code$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  and other components if they are built with USE_REAL_TEST=1$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)make metrics COMP=(component)$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  generates a code complexity metrics (cyclomatic complexity,$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  branch depth) report in $(METRICS_DIR)/.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)make memusage$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  generates a memory usage statistics report in $(METRIC_DIR)$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  If COMP is defined, generates a detailed report for that component.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)make lib/(armobjs or simsoobjs)/(component)/(filename).o$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  compiles a single source file from src/(component)$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)make lib/(armobjs or simsoobjs)/(component)/(filename).lst$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  preprocesses a single source file from src/(component)$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)make all$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  Compiles everything that can be built on the current host OS.$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)    For linux this is equivalent to$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)      'make modules'$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)    For vxWorks it's equivalent to$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)      'make IX_TARGET=vxsim loadable-all'$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)      'make IX_TARGET=vxle loadable-all vxWorks-all'$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)      'make IX_TARGET=vxbe loadable-all vxWorks-all'$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)Macros / Environment Variables:$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)-------------------------------$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)WIND_BASE, WIND_HOST_BASE$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  For vxWorks builds : The root of the Tornado installation$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  and the directory containing the \"host\" directory$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)linuxbe_KERNEL_DIR, linuxle_KERNEL_DIR, LINUX_SRC$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  For linux builds : The linux kernel source code directory for big and$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  little-endian builds respectively. If LINUX_SRC is set, it will override$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  both linuxbe_KERNEL_DIR and linuxle_KERNEL_DIR.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)HARDHAT_BASE$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  For linux builds : the root of the Monta Vista development environment install.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)IX_TARGET$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  Set to \"vxbe\" or \"vxle\" to build for XScale, \"vxsim\" for Solaris,$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  \"linuxbe\" or \"linuxle\" for linux targets.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)COMP$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  Selects a single component to build. Valid components are:$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  $(strip $(ALL_COMPONENTS))$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)IX_INCLUDE_ALL_OBJS$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  Define this to include all access library code, and all code for the selected$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  component and all its dependencies in a vxWorks OS image. Otherwise only$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  object files that are referenced by code in the selected component will$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  be included.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)IX_BYPASS_DEPS$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  Define this to disable the automatic tracking of header file dependencies.$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  This will speed up builds but may not recompile all files affected by an edit.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)IX_BYPASS_NPE$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  Define this to disable building of NPE microcode. This is the default if$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  IX_TARGET is vxsim.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)IX_CFLAGS$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  Additional compiler flags.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)IX_CONTROLLED_COUNTRY_BUILD$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  Define this to disable all cryptography support, including for the \"release\" target.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)IX_ENSURE_OFF$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  Define this to disable the IX_ENSURE macro$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)IX_PRIVATE_OFF$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  Define this to disable the PRIVATE macro$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)IX_LDFLAGS$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  Additional linker flags.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)IX_DEBUG$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  Define this to make NDEBUG undefined to enable debugging code.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)IX_NOOPT$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  Define to disable compiler optimisations$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)IX_NOSYM$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  Define to omit symbol information from the build. Default for Linux.$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)IX_EXTRA_WARNINGS$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  Define to enable additional compiler warnings (This will cause a lot of$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  warnings due to OS header files).$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)
	@echo $(ECHO_QUOTE)USE_REAL_TEST$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)  Define to use the Rational Realtime Test compiler$(ECHO_QUOTE)
	$(ECHO_BLANKLINE)

################################################################
# Output directories
#
# Other rules should depend on OUTPUT_DIR_FLAGS, never OUTPUT_DIRS.
# Depending on OUTPUT_DIRS would cause a rule to fire whenever
# any files in the output directories are modified.
#
# Because the automatic dependency rules and 'Makefile:' depend on
# OUTPUT_DIR_FLAGS, no other rules need to depend on them, as the
# dependencies are always built first.

OUTPUT_DIR_FLAGS := $(OUTPUT_DIRS:%=%/.dirCreationFlag)

$(OUTPUT_DIR_FLAGS):
	$(MAKEFILE_TRACE) Creating output directory
ifeq ($(IX_HOST_OS),windows)
# The MSDOS 'mkdir' command must use '\' as path seperator and will
# fail if the dir already exists, so we need a '-'
	-mkdir $(subst /,\,$(patsubst %/.dirCreationFlag,%,$@))
else
	mkdir -p $(patsubst %/.dirCreationFlag,%,$@)
endif
	$(TOUCH_EMPTY_FILE) $@

# If the makefile depends on something, it will always be built. Note
# that unless IX_BYPASS_DEPS is defined, the output directories are
# made anyway, because they depend on the %.d rule, which is processed
# before this one.
ifdef IX_DEPS
Makefile: $(OUTPUT_DIR_FLAGS)
endif

################################################################
# Template rules to compile C and assembler
#

# This substitution should find the component directory, including a
# trailing '/', corresponding to any source file. Note we use '=', not
# ':=', so $* is evaluated later, when it contains the stem of the
# sourcefile, relative to the src/ directory.
ASM_C_RULES_COMP_DIR = $(patsubst %/test/,%/,$(dir $*))

# This will return the include path flags and values *_CFLAGS macros
# relevant to a file whose stem is in $*.  For test code it returns
# <COMPONENT>_test_CFLAGS and <COMPONENT>_CFLAGS.  For non unit test
# code, it returns <COMPONENT>_CFLAGS twice. Hopefully that doesn't
# become a problem.
ASM_C_RULES_COMP_FOR_FILE_TEMP = $(subst /,_,$(ASM_C_RULES_COMP_DIR))
ASM_C_RULES_COMP_FOR_FILE = $(patsubst %_,%,$(ASM_C_RULES_COMP_FOR_FILE_TEMP))
ASM_C_RULES_CFLAGS_FOR_FILE = -Isrc/$(dir $*) -Isrc/$(ASM_C_RULES_COMP_DIR) \
         $($(subst /,_,$(dir $*))CFLAGS) \
         $($(subst /,_,$(ASM_C_RULES_COMP_DIR))CFLAGS) \
         -DIX_COMPONENT_NAME=ix_$(ASM_C_RULES_COMP_FOR_FILE)

ifeq ($(IX_TARGET_OS),linux)
# Define KBUILD_BASENAME to be the filename
ASM_C_RULES_CFLAGS_FOR_FILE += -DKBUILD_BASENAME=$(basename $(notdir $*))
# Define EXPORT_SYMTAB for any object file listed in ALL_EXPORT_OBJ
ASM_C_RULES_CFLAGS_FOR_FILE += $(patsubst %,-DEXPORT_SYMTAB, \
					$(filter $@,$(ALL_EXPORT_OBJ)) \
				)
endif

# Rule to build object file from c code
$(OBJ_DIR)/%.o: src/%.c
	$(MAKEFILE_TRACE) Building object file $@ from C
	$(CC) $(CFLAGS) \
		$(ASM_C_RULES_CFLAGS_FOR_FILE) $< -c -o $@

# Rule to build object file from assembler
$(OBJ_DIR)/%.o: src/%.s
	$(MAKEFILE_TRACE) Building object file $@ from asm
	$(CC) $(CFLAGS)	-P -x assembler-with-cpp \
		$(ASM_C_RULES_CFLAGS_FOR_FILE) 	$< -c -o $@


# Rule to preprocess C code into a list file
$(OBJ_DIR)/%.lst: src/%.c
	$(MAKEFILE_TRACE) Preprocessing C code to generate $@
	$(CC) $(CFLAGS) \
		$(ASM_C_RULES_CFLAGS_FOR_FILE) $< -E -o $@

################################################################
# Automatic source file dependencies

# $(OUTPUT_DIR_FLAGS) is included as a dependency of these rules
# because they are the first rules processed when 'make' starts,
# unless IX_BYPASS_DEPS is defined, in which case the 'Makefile:' rule is
# first.

# Rule to build dependency info for c
# Note the -DIX_GENERATING_DEPENDENCIES is here to bypass a #error
# directive in the CVS repository version of IxNpeMicrocode.h. See the
# comment in that file for details.
$(OBJ_DIR)/%.d: src/%.c $(OUTPUT_DIR_FLAGS)
	$(MAKEFILE_TRACE) Building dependency info for $@ from C
	$(MAKEFILE_TRACE) Building dependency by defining IX_DEPS=1 in make command 
	$(CC) -M $(CFLAGS) $(ASM_C_RULES_CFLAGS_FOR_FILE) -DIX_GENERATING_DEPENDENCIES $< > $@.tmp
	$(FILTER_DEPS) < $@.tmp > $@
	$(RM) $@.tmp
# Rule to build dependency info for assembler
$(OBJ_DIR)/%.d: src/%.s $(OUTPUT_DIR_FLAGS)
	$(MAKEFILE_TRACE) Building dependency info for $@ from asm
	$(MAKEFILE_TRACE) Building dependency by defining IX_DEPS=1 in make command 
	$(CC) -M $(CFLAGS) -x assembler-with-cpp $(ASM_C_RULES_CFLAGS_FOR_FILE) $< > $@.tmp
	$(FILTER_DEPS) < $@.tmp > $@
	$(RM) $@.tmp


# Include automatic source file dependencies, unless we've been asked
# to skip them.
DEPS := $(ALL_OBJ:.o=.d) $(patsubst src/%.h, $(OBJ_DIR)/%.d, $(ALL_NPE_HEADERS))


# Location of the microcode header
NPE_PRODUCTION_HEADER := src/npeDl/IxNpeMicrocode.c
NPE_PRODUCTION_HEADERFILE := src/include/IxNpeMicrocode.h
NPE_PRODUCTION_HEADER_OBJ := $(OBJ_DIR)/npeDl/IxNpeMicrocode.o

$(NPE_PRODUCTION_HEADER_OBJ) : $(NPE_PRODUCTION_HEADER)
	$(CC) $(CFLAGS) $< -c -o $@

NPE_CONVERTER := $(IX_XSCALE_SW)/src/npeDl/ixNpeDlImageConverter
NPE_DAT := $(IX_XSCALE_SW)/$(OBJ_DIR)/IxNpeMicrocode.dat
NPE_CONVERTER_SRC := $(IX_XSCALE_SW)/src/npeDl/ixNpeDlImageConverter.c


$(NPE_CONVERTER) : $(NPE_CONVERTER_SRC)
	cd $(IX_XSCALE_SW)/src/npeDl && \
  gcc -I$(IX_XSCALE_SW)/src/include ixNpeDlImageConverter.c -o $@

$(NPE_DAT) : $(NPE_CONVERTER)
	cd $(IX_XSCALE_SW)/$(OBJ_DIR) && $(NPE_CONVERTER)


include $(DEPS)

ifeq ($(IX_HOST_OS),linux)
ifndef IX_INCLUDE_MICROCODE
Makefile: $(NPE_CONVERTER) $(NPE_DAT)
endif
endif

################################################################
# Rules to check that macros are defined.
# Other targets can depend on these to ensure they have valid
# parameters.

# Making a rule a dependency of the Makefile means it will always be
# executed.
Makefile: assert_ix_target_valid

VX_HW_IX_TARGETS :=  vxle vxbe
VALID_IX_TARGETS :=  $(VX_HW_IX_TARGETS) vxsim linuxbe linuxle

# assert_ix_target_valid - the Makefile itself depends on this, so it's always
# executed.
.PHONY: assert_ix_target_valid
assert_ix_target_valid:
ifeq (,$(filter $(IX_TARGET), $(VALID_IX_TARGETS)))
	@echo $(ECHO_QUOTE)ERROR: You must define IX_TARGET as one of:$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)    $(VALID_IX_TARGETS)$(ECHO_QUOTE)
	@false
endif

#assert_vx_hw_target - for rules that only make sense for hardware vxWorks targets
.PHONY: assert_vx_hw_target
assert_vx_hw_target:
ifeq (,$(filter $(IX_TARGET), $(VX_HW_IX_TARGETS)))
	@echo $(ECHO_QUOTE)ERROR: This rule only works for the IX_TARGET values:$(ECHO_QUOTE)
	@echo $(ECHO_QUOTE)    $(VX_HW_IX_TARGETS)$(ECHO_QUOTE)
	@false
endif


# assert_comp_valid - check that COMP is defined to a valid component name
# used by 'lib', 'loadable', etc.
.PHONY: assert_comp_valid
assert_comp_valid:
ifndef COMP
	@echo $(ECHO_QUOTE)ERROR: You must define COMP for this rule to work$(ECHO_QUOTE)
	@false
endif
ifeq (,$(filter $(COMP), $(ALL_COMPONENTS)))
	@echo $(ECHO_QUOTE)ERROR: \"$(COMP)\" is not a valid component name$(ECHO_QUOTE)
	@false
endif

################################################################
# Macros for per-component rules

# The component directory name for a pattern rule
PATTERN_COMP_DIR = $(subst _,/,$*)
# The component object directory name for a pattern rule
PATTERN_OBJ_DIR = $(OBJ_DIR)/$(PATTERN_COMP_DIR)

################################################################
# Component code library

.PHONY: force
force:

# lib-all - build all libraries
.PHONY: lib-all
lib-all: $(COMPONENTS:%=$(OBJ_DIR)/lib%.a)

# The 'lib' target is a shortcut for specifying the entire library
# name.
.PHONY: lib
lib: $(OBJ_DIR)/lib$(COMP).a

# The list of object files for a lib%.a rule
LIB_OBJ = $($*_OBJ:%=$(PATTERN_OBJ_DIR)/%)

# This rule builds the library. The dependencies are provided by %-component-dependencies.d
$(ALL_COMPONENTS:%=$(OBJ_DIR)/lib%.a):$(OBJ_DIR)/lib%.a:
	$(MAKEFILE_TRACE) Building component library for component $*
	$(AR) rvs $@ $(LIB_OBJ)

# This rule fires if someone tries to build a library not included in the 
# rules above, i.e. one that doesn't correspond to a component. The only
# purpose of this rule is to provide a more informative error message than
# "no rule to make target librubbish.a"
$(OBJ_DIR)/lib%.a : force
	@echo $(ECHO_QUOTE)ERROR: Can't build $@ because \"$*\" is not a valid component name$(ECHO_QUOTE) # ' this comment is here to fix emacs syntax highlighting
	@false

################################################################
# Relocatable object
#
# These rules are similar to the component code library rules
# above. Read the comments on those rules to understand what's
# happening here.

ALL_LOADABLES := $(ALL_COMPONENTS:%=$(OBJ_DIR)/%.out)
.PHONY: loadable-all
loadable-all: $(ALL_LOADABLES)

# The 'loadable' is a shortcut for the full filename
.PHONY: loadable
loadable: $(OBJ_DIR)/$(COMP).out assert_comp_valid


# Full paths to the component and test objects going into the image
LOADABLE_RULE_OBJ = $($*_OBJ:%=$(PATTERN_OBJ_DIR)/%)
# The names of the libraries that will be linked to a loadable
LOADABLE_RULE_LIB_FILES = $($*_test_DEPS:%=$(OBJ_DIR)/lib%.a)

# Rule to build a loadable object
# The dependencies are provided by %-component-dependencies.d
$(ALL_LOADABLES) : $(OBJ_DIR)/%.out : osal_build $(NPE_PRODUCTION_HEADER_OBJ)
	$(MAKEFILE_TRACE) Building relocatable object for component $*
ifeq ($(IX_TARGET_OS),vxworks)
	$(NM) $(LOADABLE_RULE_OBJ) | $(MUNCH) > $(PATTERN_OBJ_DIR)/ctdt.c
	$(COMPILE_TRADITIONAL) $(CFLAGS) $(PATTERN_OBJ_DIR)/ctdt.c \
		-o  $(PATTERN_OBJ_DIR)/ctdt.o
	$(LD) $(LDFLAGS) $(LOADABLE_RULE_OBJ) $(PATTERN_OBJ_DIR)/ctdt.o\
	$(NPE_PRODUCTION_HEADER_OBJ) -L$(OBJ_DIR) -L$(OSAL_DIR)/lib/$(IX_TGT_DEVICE)/$(IX_TARGET_OS)/$(IX_TARGET) $($*_test_DEPS:%=-l%) -losal -o $@
ifdef USE_REAL_TEST
	$(RM) TP.o products.h # Left behind by attolcc
endif # ifdef USE_REAL_TEST
else # IX_TARGET_OS == vxworks
	$(LD) $(LDFLAGS)  $(LOADABLE_RULE_OBJ) \
		-L$(OBJ_DIR) $($*_test_DEPS:%=-l%) -o $@
endif # IX_TARGET_OS == vxworks

# Rule for invalid component names.
$(OBJ_DIR)/%.out : force
	@echo $(ECHO_QUOTE)ERROR: Can't build $@ because \"$*\" is not a valid component name$(ECHO_QUOTE) # ' this comment is here to fix emacs syntax highlighting
	@echo $(ECHO_QUOTE)Valid targets are: $(ALL_LOADABLES)$(ECHO_QUOTE)
	@false



################################################################
# Rules to build loadable object modules for components.
# 
# These rules are similar to the component code library rules
# above. Read the comments on those rules to understand what's
# happening here.

# The 'module' rule is a shortcut for the full filename
module: $(OBJ_DIR)/ixp400_$(COMP).o

# The list of object files for a ixp400_%.o rule
MOD_OBJ = $($*_OBJ:%=$(PATTERN_OBJ_DIR)/%)

# Rule to build the module.  Correct dependency info for this rule is provided by %-component-dependencies.d.
$(ALL_COMPONENTS:%=$(OBJ_DIR)/ixp400_%.o) : $(OBJ_DIR)/ixp400_%.o :
	$(MAKEFILE_TRACE) Building component object module for component $*
	$(LD) $(LDFLAGS) $(MOD_OBJ)  -o $@

# Rule for invalid component names.
$(OBJ_DIR)/ixp400_%.o : force
	@echo $(ECHO_QUOTE)ERROR: Can't build $@ because \"$*\" is not a valid component name$(ECHO_QUOTE) # ' this comment is here to fix emacs syntax highlighting
	@echo $(ECHO_QUOTE)Valid targets are: $(ALL_LOADABLES)$(ECHO_QUOTE)
	@false

# The 'modules' target builds every module
ALL_MODULES := $(ALL_COMPONENTS:%=$(OBJ_DIR)/ixp400_%.o)
ifneq (,$(COMPONENTS))
ALL_MODULES += $(OBJ_DIR)/ixp400.o
endif
modules: $(ALL_MODULES)


################################################################
# Rules to generate memory usage reports
.PHONY: memusage


ifdef COMP
MEMUSAGE_FILES := $($(COMP)_OBJ:%=$(OBJ_DIR)/$(COMP)/%)
MEMUSAGE_REPORT := $(METRICS_DIR)/$(COMP)-$(IX_TARGET)MemUsage.txt
memusage: $(MEMUSAGE_REPORT)

$(MEMUSAGE_REPORT) : $(MEMUSAGE_FILES) assert_comp_valid force
	$(MAKEFILE_TRACE) Generating memory usage report for $(COMP)
	$(OBJDUMP) -h $(MEMUSAGE_FILES) | buildUtils/memusage.pl | tee $@

else # def COMP

MEMUSAGE_REPORT := $(METRICS_DIR)/$(IX_TARGET)MemUsage.txt

ifeq ($(IX_TARGET_OS),vxworks)
MEMUSAGE_ACCESS_FILES := $(COMPONENTS:%=$(OBJ_DIR)/lib%.a)
ifeq ($(IX_DEVICE),ixp46X)
MEMUSAGE_ACCESS_SINGLE_FILE :=  $(OBJ_DIR)/libIxp400.a
else
MEMUSAGE_ACCESS_SINGLE_FILE :=  $(OBJ_DIR)/libIxp425.a
endif
MEMUSAGE_CODELET_FILES := $(CODELETS_COMPONENTS:%=$(OBJ_DIR)/libcodelets_%.a)
else
MEMUSAGE_ACCESS_FILES := $(COMPONENTS:%=$(OBJ_DIR)/ixp400_%.o)
MEMUSAGE_ACCESS_SINGLE_FILE :=  $(OBJ_DIR)/ixp400.o
MEMUSAGE_CODELET_FILES := $(CODELETS_COMPONENTS:%=$(OBJ_DIR)/ixp400_codelets_%.o)
endif

# Note: MEMUSAGE_*_FILES macros must _not_ contain a mix of libraries
# and object files.  See documentation in memusage.pl for details on
# why.
memusage: $(MEMUSAGE_REPORT)

$(MEMUSAGE_REPORT) : $(MEMUSAGE_ACCESS_FILES) $(MEMUSAGE_ACCESS_SINGLE_FILE) $(MEMUSAGE_CODELET_FILES) force
	$(MAKEFILE_TRACE) Generating memory usage report
	( echo "Access component memory usage:"; \
	  $(OBJDUMP) -h $(MEMUSAGE_ACCESS_FILES) | buildUtils/memusage.pl; \
	  echo; \
	  $(OBJDUMP) -h $(MEMUSAGE_ACCESS_SINGLE_FILE) | buildUtils/memusage.pl; \
	  echo; \
	  echo "Codelet memory usage:"; \
	  $(OBJDUMP) -h $(MEMUSAGE_CODELET_FILES) | buildUtils/memusage.pl; \
	) | tee $@ 


endif # def COMP


################################################################
# vxWorks OS image
# This rule builds an image containing the objects for component 
# $(COMP), linked against libIxp400.a or libIxp425.a

VXWORKS_COMP_OBJ = $($*_OBJ:%=$(PATTERN_OBJ_DIR)/%)

# The names of all dependencies of $* that are not included in
# libIxp400.a or libIxp425.a and $(COMPONENT_OBJ).
VXWORKS_NON_ACCESS_DRIVER_DEPS = $(filter-out $(COMPONENTS), $($*_test_DEPS))

ifdef IX_INCLUDE_ALL_OBJS
# If we've been asked to include everything, include every access driver 
# object, plus the object of any other dependencies of $(COMP).
# The 'filter-out' function is there to avoid duplicates.
VXWORKS_LIB_EXTRA = $(VXWORKS_COMP_OBJ) \
	$(filter-out $(VXWORKS_COMP_OBJ), $(COMPONENT_OBJ)) \
	$(foreach d, $(VXWORKS_NON_ACCESS_DRIVER_DEPS), \
		$($d_OBJ:%=$(OBJ_DIR)/$(subst _,/,$d)/%) \
	)
else # IX_INCLUDE_ALL_OBJS
# Otherwise, include $*'s object files, plus the access driver lib
# and the libs for any other dependencies.
# The difference between this and the IX_INCLUDE_ALL_OBJS case above is 
# that only objects whose code is referenced in $(COMP) will appear in 
# the final image.

ifeq ($(IX_DEVICE),ixp46X)
VXWORKS_LIB_EXTRA = $(VXWORKS_COMP_OBJ) $(patsubst %, $(OBJ_DIR)/lib%.a, $(VXWORKS_NON_ACCESS_DRIVER_DEPS)) $(OBJ_DIR)/libIxp400.a
else
VXWORKS_LIB_EXTRA = $(VXWORKS_COMP_OBJ) $(patsubst %, $(OBJ_DIR)/lib%.a, $(VXWORKS_NON_ACCESS_DRIVER_DEPS)) $(OBJ_DIR)/libIxp425.a
endif
endif # IX_INCLUDE_ALL_OBJS

# The name of the image file created by the BSP makefile when called by
# one of the OS image rules. Either "vxWorks" or "vxWorks.st"
VXWORKS_IMAGE_NAME =   $(patsubst %vxWorks,vxWorks, \
			 $(patsubst %vxWorks.st,vxWorks.st, $@) \
			)

# The BSP makefile will not rebuild the image if only the value of LIB_EXTRA
# passed to it has changed, so we delete it to always force a rebuild.
define VXWORKS_RM_IMAGE
	$(RM) $(BSP_DIR)/$(VXWORKS_IMAGE_NAME)
endef

ifeq ($(IX_HOST_OS),windows)
# The version of make shipped with Tornado for Windows won't reliably
# accept macro values from the command line, so we need this workaround.
define VXWORKS_CALL_BSP_MAKE
	cd $(BSP_DIR) $(CMD_SEP) \
	set LIB_EXTRA=$(VXWORKS_LIB_EXTRA:%=$(IX_XSCALE_SW)/%) $(CMD_SEP) \
	$(MAKE) $(VXWORKS_IMAGE_NAME) IX_TARGET=$(IX_TARGET) IX_PLATFORM=$(IX_PLATFORM) IX_DEVICE=$(IX_DEVICE) $(CMD_SEP) \
	copy /y $(subst /,\,$(BSP_DIR)/$(VXWORKS_IMAGE_NAME) $(IX_XSCALE_SW)/$@)
endef
else
define VXWORKS_CALL_BSP_MAKE
	cd $(BSP_DIR) $(CMD_SEP) \
	$(MAKE) $(VXWORKS_IMAGE_NAME) \
      	   LIB_EXTRA="$(VXWORKS_LIB_EXTRA:%=$(IX_XSCALE_SW)/%)" \
	   IX_TARGET=$(IX_TARGET) IX_PLATFORM=$(IX_PLATFORM) IX_DEVICE=$(IX_DEVICE)
	cp $(BSP_DIR)/$(VXWORKS_IMAGE_NAME) $@
endef
endif

# The vxWorks and vxWorks.st rules are shorthand for the full image names
.PHONY: vxWorks vxWorks.st

ifndef COMP
# If COMP is undefined, we build a plain vxWorks image with no xscale_sw code
vxWorks : $(OBJ_DIR)/vxWorks
vxWorks.st : $(OBJ_DIR)/vxWorks.st
else # ndef COMP
# If COMP is set, defer to a different rule to build the image with
# that component's code
vxWorks : assert_comp_valid $(OBJ_DIR)/$(COMP)-vxWorks
vxWorks.st : assert_comp_valid $(OBJ_DIR)/$(COMP)-vxWorks.st
endif # ndef comp

# Rule to build a vxWorks.st image with xscale_sw code
# Correct dependency info for this rule is provided by %-component-dependencies.d.
$(OBJ_DIR)/%-vxWorks.st : assert_vx_hw_target libIxp400 force
	$(MAKEFILE_TRACE) Calling BSP makefile to build OS image for component $*
	$(VXWORKS_RM_IMAGE)
	$(VXWORKS_CALL_BSP_MAKE)
# Rule to build a vxWorks image with xscale_sw code
# Correct dependency info for this rule is provided by %-component-dependencies.d.
$(OBJ_DIR)/%-vxWorks : assert_vx_hw_target libIxp400 force
	$(MAKEFILE_TRACE) Calling BSP makefile to build OS image for component $*
	$(VXWORKS_RM_IMAGE)
	$(VXWORKS_CALL_BSP_MAKE)

# Rule to build a plain vxWorks.st image with no xscale_sw code
$(OBJ_DIR)/vxWorks.st : assert_vx_hw_target libIxp400 force
	$(MAKEFILE_TRACE) Calling BSP makefile to build OS image
	$(VXWORKS_RM_IMAGE)
	$(VXWORKS_CALL_BSP_MAKE)
# Rule to build a plain vxWorks image with no xscale_sw code
$(OBJ_DIR)/vxWorks : assert_vx_hw_target libIxp400 force
	$(MAKEFILE_TRACE) Calling BSP makefile to build OS image
	$(VXWORKS_RM_IMAGE)
	$(VXWORKS_CALL_BSP_MAKE)


# vxWorks-all - build a vxWorks image for all components.
.PHONY: vxWorks-all
vxWorks-all: $(ALL_COMPONENTS:%=$(OBJ_DIR)/%-vxWorks) $(OBJ_DIR)/vxWorks


################################################################
# Dependencies for per-component rules

# It is not possible to specify something like $($*_OBJ) as the
# dependencies of a rule like "lib%.a" rule, so we generate a .d file
# which explicitly states the dependencies for all such rules, and
# "include" it in the makefile.

$(OBJ_DIR)/%-component-dependencies.d: $(OUTPUT_DIR_FLAGS)
	$(MAKEFILE_TRACE) Writing dependency info to $@
# The objects required for the component library
	echo $(OBJ_DIR)/lib$*.a : $(LIB_OBJ) >$@
# Objects and libs for the 'loadable' rule
	echo $(OBJ_DIR)/$*.out : $(LOADABLE_RULE_OBJ) $(LOADABLE_RULE_LIB_FILES) >>$@
# Objects the 'module' rule
	echo $(OBJ_DIR)/ixp400_$*.o : $(MOD_OBJ) >>$@
# Objects and libs for 'vxWorks' rules
	echo $(OBJ_DIR)/$*-vxWorks $(OBJ_DIR)/$*-vxWorks.st : $(VXWORKS_LIB_EXTRA) >>$@
# Make sure the .d gets rebuilt for makefile changes
	echo $@ : Makefile src/$(PATTERN_COMP_DIR)/component.mk  >>$@

include $(ALL_COMPONENTS:%=$(OBJ_DIR)/%-component-dependencies.d)


################################################################
# Global rules

# all - build everything that can be built on the current host
#
# To allow 'make -j' to work effectively, we have seperate rules for
# the parts of a 'make all' that can run in paralell


ifndef COMP # defining COMP will restrict the 'make all' to one component

ifeq ($(IX_TARGET_OS),vxworks)
ALL_SUB_RULES := all_vxbe all_vxle

ALL_XSCALE_SW_TARGETS := usage loadable-all
ALL_BSP_TARGETS := vxWorks-all bootrom

# The following rules execute builds for each of the IX_TARGET
# values for vxworks
all_vxle all_vxbe : all_% :
	$(MAKE) IX_TARGET=$* IX_PLATFORM=$(IX_PLATFORM) IX_DEVICE=$(IX_DEVICE) $(ALL_XSCALE_SW_TARGETS)
# The BSP makefile targets cannot run in parallel, so we use -j1 to cancel
# any -j flags already specified.
ifeq ($(IX_HOST_OS),windows)
	$(MAKE) IX_TARGET=$* IX_PLATFORM=$(IX_PLATFORM) IX_DEVICE=$(IX_DEVICE) $(ALL_BSP_TARGETS)
else
	$(MAKE) -j1 IX_TARGET=$* IX_PLATFORM=$(IX_PLATFORM) IX_DEVICE=$(IX_DEVICE) $(ALL_BSP_TARGETS)
endif

all_vxsim:
	$(MAKE) IX_TARGET=vxsim IX_PLATFORM=$(IX_PLATFORM) IX_DEVICE=$(IX_DEVICE) $(ALL_XSCALE_SW_TARGETS)

else # IX_TARGET_OS

ALL_SUB_RULES += all_linuxbe all_linuxle

all_linuxle :
	$(MAKE) IX_TARGET=linuxle IX_PLATFORM=$(IX_PLATFORM) IX_DEVICE=$(IX_DEVICE) modules

all_linuxbe :
	$(MAKE) IX_TARGET=linuxbe IX_PLATFORM=$(IX_PLATFORM) IX_DEVICE=$(IX_DEVICE) modules


endif # IX_TARGET_OS

.PHONY: all $(ALL_SUB_RULES)
all: $(ALL_SUB_RULES)

else # COMP is defined

ifeq ($(IX_TARGET_OS),vxworks)
all: force
	$(MAKE) IX_TARGET=vxbe IX_PLATFORM=$(IX_PLATFORM) IX_DEVICE=$(IX_DEVICE) loadable vxWorks
	$(MAKE) IX_TARGET=vxle IX_PLATFORM=$(IX_PLATFORM) IX_DEVICE=$(IX_DEVICE) loadable vxWorks
	$(MAKE) IX_TARGET=vxsim IX_PLATFORM=$(IX_PLATFORM) IX_DEVICE=$(IX_DEVICE) loadable
else # IX_TARGET_OS
all:
	$(MAKE) IX_TARGET=linuxbe IX_PLATFORM=$(IX_PLATFORM) IX_DEVICE=$(IX_DEVICE) modules
	$(MAKE) IX_TARGET=linuxle IX_PLATFORM=$(IX_PLATFORM) IX_DEVICE=$(IX_DEVICE) modules
endif # IX_TARGET_OS

endif # COMP

################################################################
# vxWorks bootrom

.PHONY: bootrom
bootrom: libIxp400
	$(MAKEFILE_TRACE) Calling BSP makefile to build $@
	cd $(BSP_DIR) $(CMD_SEP) $(MAKE) bootrom IX_TARGET=$(IX_TARGET) IX_DEVICE=$(IX_DEVICE)

################################################################
# Library containing all component code

ifeq ($(IX_DEVICE),ixp46X)
libIxp400 : $(OBJ_DIR)/libIxp400.a $(NPE_PRODUCTION_HEADER_OBJ) $(OSAL_MODULE)

$(OBJ_DIR)/libIxp400.a : $(COMPONENT_OBJ) $(NPE_PRODUCTION_HEADER_OBJ) $(OSAL_MODULE) 
	$(MAKEFILE_TRACE) Building Ixp400 library containing components $(COMPONENTS:%=\"%\")
	$(AR) rvs $(OBJ_DIR)/libIxp400.a $^
else
libIxp400 : $(OBJ_DIR)/libIxp425.a $(NPE_PRODUCTION_HEADER_OBJ) $(OSAL_MODULE)

$(OBJ_DIR)/libIxp425.a : $(COMPONENT_OBJ) $(NPE_PRODUCTION_HEADER_OBJ) $(OSAL_MODULE)
	$(MAKEFILE_TRACE) Building Ixp400 library containing components $(COMPONENTS:%=\"%\")
	$(AR) rvs $(OBJ_DIR)/libIxp425.a $^
endif

################################################################
# Loadable module containing all component code

ixp400.o : $(OBJ_DIR)/ixp400.o
################################################################
## changed as following, lizhijie, 2005.07.11
ifndef IX_INCLUDE_MICROCODE
$(OBJ_DIR)/ixp400.o: $(COMPONENTS:%=$(OBJ_DIR)/ixp400_%.o) $(OSAL_MODULE)
	$(LD) $(LDFLAGS) $^ -o $@
else
$(OBJ_DIR)/ixp400.o: $(COMPONENTS:%=$(OBJ_DIR)/ixp400_%.o) $(NPE_PRODUCTION_HEADER_OBJ) $(OSAL_MODULE)
	$(LD) $(LDFLAGS) $^ -o $@
endif

# $(OBJ_DIR)/ixp400_oslinux.o
IXP422_COMPONENTS= \
		$(OBJ_DIR)/ixp400_dmaAcc.o \
		$(OBJ_DIR)/ixp400_osServices.o \
		$(OBJ_DIR)/ixp400_ossl.o \
		$(OBJ_DIR)/ixp400_featureCtrl.o \
		$(OBJ_DIR)/ixp400_perfProfAcc.o \
		$(OBJ_DIR)/ixp400_ethMii.o \
		$(OBJ_DIR)/ixp400_ethDB.o \
		$(OBJ_DIR)/ixp400_ethAcc.o \
		$(OBJ_DIR)/ixp400_npeDl.o \
		$(OBJ_DIR)/ixp400_npeMh.o \
		$(OBJ_DIR)/ixp400_qmgr.o        
		
# ifndef IX_INCLUDE_MICROCODE
# $(OBJ_DIR)/ixp400.o: $(IXP422_COMPONENTS) $(OSAL_MODULE)
# 	$(LD) $(LDFLAGS) $^ -o $@
# else
# $(OBJ_DIR)/ixp400.o: $(IXP422_COMPONENTS) $(NPE_PRODUCTION_HEADER_OBJ) $(OSAL_MODULE)
#	$(LD) $(LDFLAGS) $^ -o $@
# endif
# end of modified by lizhijie, 2005.07.11
#################################################################


################################################################
# clean - deletes everything that can be rebuilt
.PHONY: clean bsp_clean xscale_sw_clean

clean: xscale_sw_clean

ifeq ($(IX_TARGET_OS),vxworks)
clean: bsp_clean
endif


xscale_sw_clean:
	$(MAKEFILE_TRACE) Deleting all build products
ifeq ($(IX_HOST_OS),windows)
ifeq ($(IX_DEVICE),ixp42X)
	rmdir /q /s lib
else
	rmdir /q /s ixp46X 
endif
else
ifeq ($(IX_DEVICE),ixp42X)
	$(RM) -r lib $(NPE_CONVERTER)
else
	$(RM) -r ixp46X $(NPE_CONVERTER)
endif
endif

################################################################
# bsp_clean - make clean in the vxWorks BSP directory
bsp_clean:
ifeq ($(IX_DEVICE),ixp42X)
	$(MAKEFILE_TRACE) Doing make clean in BSP directory
	cd $(WIND_BASE)/target/config/ixdp425 $(CMD_SEP) \
	$(MAKE) clean
	cd $(WIND_BASE)/target/config/ixdp425_le $(CMD_SEP) \
	$(MAKE) clean
else
	cd $(WIND_BASE)/target/config/ixdp465 $(CMD_SEP) \
	$(MAKE) clean
#	cd $(WIND_BASE)/target/config/ixdp465_le $(CMD_SEP) \
#	$(MAKE) clean
endif




################################################################
# showmacro - prints the value of a variable. For makefile debugging.
.PHONY: showmacro
showmacro:
	@echo $($(MACRO))


.PHONY: script
script:
	$(SCRIPT)
